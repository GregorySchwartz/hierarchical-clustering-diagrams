{-# LANGUAGE BangPatterns, FlexibleContexts #-}

module Diagrams.Dendrogram
    ( dendrogram
    , dendrogramPath
    , fixedWidth
    , variableWidth
    ) where

-- from base
import Control.Arrow (second)

-- from hierarachical-clustering
import Data.Clustering.Hierarchical (Dendrogram(..), elements)

-- from diagrams-lib
import Diagrams.Prelude


-- | @dendrogram drawItem dendro@ is a drawing of the dendrogram
-- @dendro@ using @drawItem@ to draw its leafs.
dendrogram :: (Monoid m, Renderable (Path R2) b) =>
              (a -> AnnDiagram b R2 m)
              -> Dendrogram a
              -> AnnDiagram b R2 m
dendrogram drawItem dendro = (stroke path_ # value mempty) === items
  where
    drawItems d = hcat [drawItem a # alignT # named n | (a, n) <- elements d]

    dendroPath (Leaf (_, n))  = (mempty, getPos n)
    dendroPath (Branch d l r) = (path <> pathL <> pathR, pos)
        where
          (pathL, P (xL, yL)) = dendroPath l
          (pathR, P (xR, yR)) = dendroPath r

          path = fromVertices [ P (xL, yL)
                              , P (xL, d+y0)
                              , P (xR, d+y0)
                              , P (xR, yR)]
          pos  = P ((xL + xR) / 2, d+y0)

    named_     = numbered dendro
    items      = drawItems named_
    names_     = names items
    getPos n   = let Just [(p, _)] = lookupN n names_ in p
    (path_, _) = dendroPath named_

    Just [(P (_, y0), _)] = lookupN (0 :: Int) names_

numbered :: Dendrogram a -> Dendrogram (a, Int)
numbered = snd . go 0
    where
      go n (Leaf a) = n `seq` (n+1, Leaf (a,n))
      go n (Branch d l r) =
          let (n', l') = go n l
          in second (Branch d l') (go n' r)


-- | A dendrogram path that can be 'stoke'd later.  This function
-- assumes that the 'Leaf'@s@ of your 'Dendrogram' are already in
-- the right position.
dendrogramPath :: Dendrogram Y -> Path R2
dendrogramPath = mconcat . fst . go []
    where
      go acc (Leaf y)       = (acc, (0, y))
      go acc (Branch d l r) = (path : acc'', pos)
        where
          (acc',  (!xL, !yL)) = go acc  l
          (acc'', (!xR, !yR)) = go acc' r

          path = fromVertices [ P (xL, yL)
                              , P (xL, d)
                              , P (xR, d)
                              , P (xR, yR)]
          pos  = ((xL + xR) / 2, d)


-- | The horizontal position of a dendrogram Leaf.
type Y = Double


-- | @fixedWidth w@ positions the 'Leaf'@s@ of a 'Dendrogram'
-- assuming that they have the same width @w@.  Also returns the
-- total width.
fixedWidth :: Width -> Dendrogram a -> (Dendrogram Y, Width)
fixedWidth w = second (subtract half_w) . go half_w
    where
      half_w = w/2
      go !y (Leaf _)       = (Leaf y, y + w)
      go !y (Branch d l r) = (Branch d l' r', y'')
          where
            (l', !y')  = go y  l
            (r', !y'') = go y' r


-- | @variableWidth draw@ positions the 'Leaf'@s@ of a
-- 'Dendrogram' according to the diagram generated by 'draw'.
-- Each 'Leaf' may have a different width.  Also returns the
-- resulting diagram having all 'Leaf'@s@ drawn side-by-side.
--
-- Note: you should probably use 'alignT' to align your items.
variableWidth :: (Monoid m) =>
                 (a -> AnnDiagram b R2 m)
              -> Dendrogram a
              -> (Dendrogram Y, AnnDiagram b R2 m)
variableWidth draw = finish . go 0
    where
      go !y (Leaf a) = (Leaf y', y'', dia)
          where
            dia  = draw a
            !w   = width dia
            !y'  = y + w/2
            !y'' = y + w
      go !y (Branch d l r) = (Branch d l' r', y'', diaL <> diaR)
          where
            (l', !y',  diaL) = go y  l
            (r', !y'', diaR) = go y' r
      finish (dendro, _, dia) = (dendro, dia)


-- | The width of something.
type Width = Double